//
//  String+Additions.swift
//  e2e
//
//  Created by Guillermo Giampietro on 3/29/16.
//  Copyright Â© 2016 Altimetrik. All rights reserved.
//

import Foundation

extension String {
    /**
     Test if is a empty string, triming it before.
     - returns: false if is a empty string other true
     */
    func isNotEmpty() -> Bool {
        return !self.trimmingCharacters(in: CharacterSet.whitespaces).isEmpty
    }
    /*func join<S: SequenceType>(elements: S) -> String {
        return elements.map{ String($0) }.joinWithSeparator(self)
    }
    func indexOf(substring: String) -> Int? {
        if let range = rangeOfString(substring) {
            return startIndex.distanceTo(range.startIndex)
        }
        return nil
    }
    func substring(startIndex: Int, length: Int) -> String {
        let start = self.startIndex.advancedBy(startIndex)
        let end = self.startIndex.advancedBy(startIndex + length)
        return self[start..<end]
    }*/
    ///  Finds the string between two bookend strings if it can be found.
    ///
    ///  - parameter left:  The left bookend
    ///  - parameter right: The right bookend
    ///
    ///  - returns: The string between the two bookends, or nil if the bookends cannot be found, the bookends are the same or appear contiguously.
    func between(_ left: String, _ right: String) -> String? {
        guard
            let leftRange = range(of: left), let rightRange = range(of: right, options: .backwards), left != right && leftRange.upperBound != rightRange.lowerBound
            else { return nil }

        return self[leftRange.upperBound...index(before: rightRange.lowerBound)]

    }

    // https://gist.github.com/stevenschobert/540dd33e828461916c11
    func camelize() -> String {
        let source = clean(with: " ", allOf: "-", "_")
        if source.characters.contains(" ") {
            let first = source.substring(to: source.characters.index(source.startIndex, offsetBy: 1))
            let cammel = NSString(format: "%@", (source as NSString).capitalized.replacingOccurrences(
                of: " ", with: "", options: [], range: nil)) as String
            let rest = String(cammel.characters.dropFirst())
            return "\(first)\(rest)"
        } else {
            let first = (source as NSString).lowercased.substring(to: source.characters.index(source.startIndex, offsetBy: 1))
            let rest = String(source.characters.dropFirst())
            return "\(first)\(rest)"
        }
    }

    func capitalize() -> String {
        return capitalized
    }

    /*func contains(substring: String) -> Bool {
        return rangeOfString(substring) != nil
    }*/

    func chompLeft(_ prefix: String) -> String {
        if let prefixRange = range(of: prefix) {
            if prefixRange.upperBound >= endIndex {
                return self[startIndex..<prefixRange.lowerBound]
            } else {
                return self[prefixRange.upperBound..<endIndex]
            }
        }
        return self
    }

    func chompRight(_ suffix: String) -> String {
        if let suffixRange = range(of: suffix, options: .backwards) {
            if suffixRange.upperBound >= endIndex {
                return self[startIndex..<suffixRange.lowerBound]
            } else {
                return self[suffixRange.upperBound..<endIndex]
            }
        }
        return self
    }

    func collapseWhitespace() -> String {
        let components = self.components(separatedBy: CharacterSet.whitespacesAndNewlines).filter { !$0.isEmpty }
        return components.joined(separator: " ")
    }

    func clean(with: String, allOf: String...) -> String {
        var string = self
        for target in allOf {
            string = string.replacingOccurrences(of: target, with: with)
        }
        return string
    }

    func count(_ substring: String) -> Int {
        return components(separatedBy: substring).count-1
    }

    func endsWith(_ suffix: String) -> Bool {
        return hasSuffix(suffix)
    }

    func ensureLeft(_ prefix: String) -> String {
        if startsWith(prefix) {
            return self
        } else {
            return "\(prefix)\(self)"
        }
    }

    func ensureRight(_ suffix: String) -> String {
        if endsWith(suffix) {
            return self
        } else {
            return "\(self)\(suffix)"
        }
    }

    func indexOf(_ substring: String) -> Int? {
        if let range = range(of: substring) {
            return characters.distance(from: startIndex, to: range.lowerBound)
        }
        return nil
    }

    func initials() -> String {
        let words = self.components(separatedBy: " ")
        return words.reduce("") { $0 + $1[0...0] }
    }

    func initialsFirstAndLast() -> String {
        let words = self.components(separatedBy: " ")
        return words.reduce("") { ($0 == "" ? "" : $0[0...0]) + $1[0...0]}
    }

    func isAlpha() -> Bool {
        for chr in characters {
            if !(chr >= "a" && chr <= "z") && !(chr >= "A" && chr <= "Z") {
                return false
            }
        }
        return true
    }

    func isAlphaNumeric() -> Bool {
        let alphaNumeric = CharacterSet.alphanumerics
        return components(separatedBy: alphaNumeric).joined(separator: "").length == 0
    }

    func isEmpty() -> Bool {
        return self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines).length == 0
    }

    func isNumeric() -> Bool {
        if let _ = NumberFormatter().number(from: self) {
            return true
        }
        return false
    }

    func join<S: Sequence>(_ elements: S) -> String {
        return elements.map { String(describing: $0) }.joined(separator: self)
    }

    func latinize() -> String {
        return self.folding(options: .diacriticInsensitive, locale: Locale.current)
    }

    func lines() -> [String] {
        return self.components(separatedBy: CharacterSet.newlines)
    }

    var length: Int {
        get {
            return self.characters.count
        }
    }

    func pad(_ num: Int, _ string: String = " ") -> String {
        return "".join([string.times(num), self, string.times(num)])
    }

    func padLeft(_ num: Int, _ string: String = " ") -> String {
        return "".join([string.times(num), self])
    }

    func padRight(_ num: Int, _ string: String = " ") -> String {
        return "".join([self, string.times(num)])
    }

    func slugify(withSeparator separator: Character = "-") -> String {
        let slugCharacterSet = CharacterSet(charactersIn: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\(separator)")
        return latinize().lowercased()
            .components(separatedBy: slugCharacterSet.inverted)
            .filter { $0 != "" }
            .joined(separator: String(separator))
    }

    func split(_ separator: Character) -> [String] {
        return characters.split { $0 == separator }.map(String.init)
    }

    func startsWith(_ prefix: String) -> Bool {
        return hasPrefix(prefix)
    }

    func stripPunctuation() -> String {
        return components(separatedBy: .punctuationCharacters)
            .joined(separator: "")
            .components(separatedBy: " ")
            .filter { $0 != "" }
            .joined(separator: " ")
    }

    func times(_ num: Int) -> String {
        return (0..<num).reduce("") { $0.0 + self }
    }

    func toFloat() -> Float? {
        if let number = NumberFormatter().number(from: self) {
            return number.floatValue
        }
        return nil
    }

    func toInt() -> Int? {
        if let number = NumberFormatter().number(from: self) {
            return number.intValue
        }
        return nil
    }

    func toDouble(_ locale: Locale = Locale.current) -> Double? {
        let nf = NumberFormatter()
        nf.locale = locale
        if let number = nf.number(from: self) {
            return number.doubleValue
        }
        return nil
    }

    func toBool() -> Bool? {
        let trimmed = self.trimmed().lowercased()
        if trimmed == "true" || trimmed == "false" {
            return (trimmed as NSString).boolValue
        }
        return nil
    }

    func toDate(_ format: String = "yyyy-MM-dd") -> Date? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = format
        return dateFormatter.date(from: self)
    }

    func toDateTime(_ format: String = "yyyy-MM-dd HH:mm:ss") -> Date? {
        return toDate(format)
    }

    func trimmedLeft() -> String {
        if let range = rangeOfCharacter(from: CharacterSet.whitespacesAndNewlines.inverted) {
            return self[range.lowerBound..<endIndex]
        }
        return self
    }

    func trimmedRight() -> String {
        if let range = rangeOfCharacter(from: CharacterSet.whitespacesAndNewlines.inverted, options: NSString.CompareOptions.backwards) {
            return self[startIndex..<range.upperBound]
        }
        return self
    }

    func trimmed() -> String {
        return self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
    }

    subscript(ran: Range<Int>) -> String {
        get {
            let startIndex = self.characters.index(self.startIndex, offsetBy: ran.lowerBound)
            let endIndex = self.characters.index(self.startIndex, offsetBy: ran.upperBound - ran.lowerBound)
            return self[startIndex..<endIndex]
        }
    }

    func substring(_ startIndex: Int, length: Int) -> String {
        let start = self.characters.index(self.startIndex, offsetBy: startIndex)
        let end = self.characters.index(self.startIndex, offsetBy: startIndex + length)
        return self[start..<end]
    }

    subscript(ind: Int) -> Character {
        get {
            let index = self.characters.index(self.startIndex, offsetBy: ind)
            return self[index]
        }
    }
}
